# 트리의 구현과 순회

## 1. 기본적인 정의와 용어
1. 트리의 구성 요소
   1. 노드 : 자료가 저장된 곳
   2. 간선 : 노드 간 연결
   3. 부모 : 두 연결된 노드 중 상위 노드
   4. 자식 : 두 연결된 노드 중 하위 노드
   5. 형제 : 부모 노드가 같은 두 노드
   6. 선조 : 부모 노드와 그의 부모들을 통틀어
   7. 자손 : 자식 노드와 그의 자식들을 통틀어
   8. 루트 노드 : 트리의 뿌리 노드
   9. 리프 노드 : 자식이 하나도 없는 노드

> 트리에서 한 노드는 여러개의 자식 노드를 가질 수 있지만 부모는 하나만 가질 수 있음

2. 트리와 노드의 특성
   트리의 깊이 : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 단계
   트리의 높이 : 가장 깊이 있는 노드의 깊이


3. 트리의 재귀적 특성
   1. 트리에서 한 노드와 그의 자손들은 모두 모으면 하나의 트리가 된다.
   2. 어떤 노드 t와 그 자손들로 구성된 트리를 't를 루트로 하는 서브트리'라고 한다.
   3. 트리는 루트와 루트 밑에 있는 서브트리들의 집합이라고 할 수 있다.

4. 트리의 노드를 표현하는 객체의 구현

```c++
struct TreeNode {
  string label;
  TreeNode* parent;
  vector<TreeNode*> children;
}
```

## 2. 트리의 순회
트리를 순회하기 위해서는 트리의 재귀적 속성을 이용해야 한다.

1. 트리의 순회(전위 순회)
```c++
void printLabel(TreeNode* root) {
  cout << root->label << '\n';

  for(int i = 0; i < root->children.size(); i++) {
    printLabel(root->children[i]);
  }
}
```

> children필드에 저장된 노드들은 직계자식이며 자손이 아님


2. 트리의 순회(재귀적으로 트리의 높이 구하기(최대 깊이))

```cpp
int height(TreeNode* root) {
  int h = 0;
  for(int i = 0; i < root->children.size(); i++) {
    h = max(h, 1 + height(root->children[i]));
    /// 자식이 한개 있는 경우 이므로 1더해주고 그 자식의 높이를 더하면 현재 노드의 높이가 되는 것임
  }

  return h;
}
```
> height(node) = max(cur, 1 + height(node's children))


## 문제 : 트리의 순회 순서 변경
트리의 순회 방식은 4가지가 있다.
1. 전위 순회 : 맨 처음에 트리의 루트를 방문하고, 왼쪽 서브트리를 방문한 뒤 오른쪽 서브 트리를 방문함
2. 중위 순회 : 맨 처음에 왼쪽 서브트리를 방문한 뒤 루트를 방문하고 오른쪽 서브트리를 방문한다.
3. 후위 순회 : 왼쪽 서브트리를 방문한 뒤 오른쪽 서브트리를 방문하고 루트를 방문한다.

입력
입력의 첫 줄은 테스트 케이스의 개수이며, 각 테스트 케이스는 3줄로 구성된다.
노드의 개수 N, 전위 순회시 방문 순서, 중위 순회시 방문 순서

예제 입력 예시
```text
1
7
27 16 9 12 54 36 72
9 12 16 27 36 54 72
```

예제 출력
```text
12 9 16 36 72 54 27
```

## 나의 풀이
트리의 전위 순회를 통해서 알 수 있는 것은 루트 노드의 값이다.
첫번 째 예시에 대해서 27이 루트라는 것을 알 수 있으며 중위 순회에서 27을 기준으로 왼쪽에 위치한 수들은 27을 루트로 하여 왼쪽의 서브트리로 구성되는 수들이다.

따라서 
9 12 16 `27` 36 54 72 라는 것을 알 수 있다.

왼쪽 서브트리 9 12 16에 대해서 전위 순회시 값이 16이므로 16이 루트라는 것을 알 수 있다.
16을 루트로 하여 왼쪽서브트리에 9와 12가 있는 것이고 오른쪽 서브트리는 비어 있는 것을 알 수 있다.

따라서
9 12 `16` 라는 것을 알 수 있다.

왼쪽 서브트리 9 12에 대해서 전위 순회시 값이 9이므로 9를 루트로 하여 오른쪽 서브트리에 12가 있다는 것을 알 수 있다. 

따라서
`9` 12 라는 것을 알 수 있다.

마찬가지로 27의 오른쪽 서브트리에 대해서 조사하면 전위 순회시 값이 54이므로 54를 루트로 하여 왼쪽으로 36 오른쪽으로 72이가 있다는 것을 알 수 있다.

따라서 
    27
   /  \
  16   54
 /    /  \
9    36  72
 \
  12


### 추가 설명
- 위 예시에서 27을 기준으로 왼쪽 서브트리와 오른쪽 서브트리로 나누는 과정을 정리해보면 27을 기준으로 왼쪽의 개수만 큼 전위 순회 배열과 중위 순회 배열을 잘라야 한다. 하지만 전위 순회배열로 구한 루트를 제외해야 한다.

- 전위 순회 배열이 다음과 같을 때 왼쪽 서브트리가 사용할 전위 순회 배열은 L개 만큼 잘라야 하며 루트를 제외 해야 한다(L은 27을 기준으로 왼쪽의 서브트리에 존재하는 노드의 개수이며 이는 3이라는 것을 알 수 있다.)

27 16 9 12 54 36 72 에서
16 9 12가 왼쪽 서브트리의 전위 순회 배열이다

마찬 가지로 오른쪽 서브트리의 개수는 3개 이므로
오른쪽 서브트리의 전위 순회 배열은 54 36 72 이다.

- 중위 순회 배열은 전위 순회 배열에서 구한 루트를 제외한 L개씩 왼쪽 서브트리의 중위 순회 배열과 오른쪽 서브트리의 중위 순회 배열로 전달하면 된다.

```cpp
#include <bits/stdc++.h>
#define all(x) begin(x), end(x)
using namespace std;

vector<int> pre;
vector<int> in;

vector<int> slice(const vector<int>& v, int a, int b) { /// a부터 b까지 서브 벡터 구함
  return vector<int>(v.begin() + a, v.begin() + b);
}

void sol(const vector<int>& preSub, const vector<int>& inSub) {
  // [i, j] root [k, l]
  int N = preSub.size();
  if(N == 0) return;
  
  int root = preSub[0]; /// 루트 노드
  int L = find(all(inSub), root) - inSub.begin(); 
  /// 이는 루트 노드의 인덱스이며 L + 1 은 루트 노드를 포함한 원소의 개수이다.

  sol(::slice(preSub, 1, L + 1), ::slice(inSub, 0, L));
  sol(::slice(preSub, L + 1, N), ::slice(inSub, L + 1, N));

  // 슬라이스 함수에서 b는 past of end이므로 포함되지 않는다.

  cout << root << ' ';
}

int main(void) {
  int T;
  cin >> T;

  while(T--) {
    int n;
    cin >> n;

    pre.resize(n, 0);
    in.resize(n, 0);

    for(int i = 0; i < n; i++) cin >> pre[i];
    for(int i = 0; i < n; i++) cin >> in[i];

    sol(pre, in);
  }


  return 0;
} 
```

## 요새 문제
요새 문제는 원의 중심과 반지름이 주어지며 가장 많은 지점을 경우해서 이동할 수 있는 지점간의 거리를 구하는 문제이다.

입력
```text
C
N
x1 x2 r1
...
```

출력
```text
2
5
```

## 문제 설명
만약 리프 노드가 아닌 중간 노드와 다른 리프노드간의 길이가 최대라고 가정한다면
중간 노드는 자식노드가 있으므로 중간 노드의 자식노드를 반영한 길이가 최대가 될 것이다.

만약 원안에 중첩해서 원이 위치한 경우 결국 루트노드부터 리프노드간의 높이가 정답이 될 것이다.
그 경우가 아니라면 루트 노드부터 리프노드간의 높이와 리프 노드간의 거리중 최대값이 정답이 될 것이다.

특정 노드를 기준으로 왼쪽 서브트리의 높이(여기서의 높이는 최대 깊이를 의미한다)와 오른쪽 서브트리의 높이값을 구한 뒤 + 2한 값이 후보가 될 수 있을 것이다.

재귀호출을 통해서 각 노드의 높이를 구함과 동시에 왼쪽 노드의 높이와 오른쪽 노드의 높이값 + 2 값을 전체를 순회하는 동안 최대값으로 갱신하면 문제를 해결할 수 있다.

## 구현
